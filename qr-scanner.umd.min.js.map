{"version":3,"file":"qr-scanner.umd.min.js","sources":["src/qr-scanner.js"],"sourcesContent":["export default class QrScanner {\n    static async hasCamera() {\n        try {\n            return !!(await QrScanner.listCameras(false)).length;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    static async listCameras(requestLabels = false) {\n        if (!navigator.mediaDevices) return [];\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, ask for camera permission by opening a stream, if\n        // labels were requested.\n        let openedStream = null;\n        if (requestLabels) {\n            try {\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n            } catch (e) {\n                // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in\n                // use and some browsers disallow a second stream.\n            }\n        }\n        try {\n            const devices = await navigator.mediaDevices.enumerateDevices();\n            return devices.filter(device => device.kind === 'videoinput').map((device, i) => ({\n                id: device.deviceId,\n                label: device.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            }));\n        } finally {\n            // close the stream we just opened for getting camera access for listing the device labels\n            if (openedStream) {\n                for (const track of openedStream.getTracks()) {\n                    track.stop();\n                    openedStream.removeTrack(track);\n                }\n            }\n        }\n    }\n\n    constructor(\n        video,\n        onDecode,\n        canvasSizeOrOnDecodeError = this._onDecodeError,\n        canvasSizeOrCalculateScanRegion = this._calculateScanRegion,\n        preferredCamera = 'environment'\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE;\n        this._preferredCamera = preferredCamera;\n        this._active = false;\n        this._paused = false;\n        this._flashOn = false;\n\n        if (typeof canvasSizeOrOnDecodeError === 'number') {\n            // legacy function signature where the third argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrOnDecodeError;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._onDecodeError = canvasSizeOrOnDecodeError;\n        }\n\n        if (typeof canvasSizeOrCalculateScanRegion === 'number') {\n            // legacy function signature where the fourth argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrCalculateScanRegion;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._calculateScanRegion = canvasSizeOrCalculateScanRegion;\n        }\n\n        this._scanRegion = this._calculateScanRegion(video);\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const computedStyle = window.getComputedStyle(video);\n            if (computedStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (computedStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = 0;\n                video.style.width = 0;\n                video.style.height = 0;\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    async hasFlash() {\n        let stream = null;\n        try {\n            stream = this.$video.srcObject || (await this._getCameraStream()).stream;\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\n        } catch (e) {\n            return false;\n        } finally {\n            // close the stream we just opened for detecting whether it supports flash\n            if (stream && stream !== this.$video.srcObject) {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                for (const track of stream.getTracks()) {\n                    track.stop();\n                    stream.removeTrack(track);\n                }\n            }\n        }\n    }\n\n    isFlashOn() {\n        return this._flashOn;\n    }\n\n    async toggleFlash() {\n        if (this._flashOn) {\n            await this.turnFlashOff();\n        } else {\n            await this.turnFlashOn();\n        }\n    }\n\n    async turnFlashOn() {\n        if (this._flashOn) return;\n        this._flashOn = true;\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\n        try {\n            if (!await this.hasFlash()) throw 'No flash available';\n            // Note that the video track is guaranteed to exist at this point\n            await this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n                advanced: [{ torch: true }],\n            });\n        } catch (e) {\n            this._flashOn = false;\n            throw e;\n        }\n    }\n\n    async turnFlashOff() {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        await this._restartVideoStream();\n    }\n\n    destroy() {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    async start() {\n        if (this._active && !this._paused) return;\n\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n\n        this._active = true;\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return;\n        }\n\n        try {\n            const { stream, facingMode } = await this._getCameraStream();\n            this.$video.srcObject = stream;\n            this.$video.play();\n            this._setVideoMirror(facingMode);\n\n            // Restart the flash if it was previously on\n            if (this._flashOn) {\n                this._flashOn = false; // force turnFlashOn to restart the flash\n                this.turnFlashOn().catch(() => {});\n            }\n        } catch (e) {\n            this._active = false;\n            throw e;\n        }\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    async pause(stopStreamImmediately = false) {\n        this._paused = true;\n        if (!this._active) return true;\n        this.$video.pause();\n\n        const stopStream = () => {\n            const tracks = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];\n            for (const track of tracks) {\n                track.stop(); //  note that this will also automatically turn the flashlight off\n                this.$video.srcObject.removeTrack(track);\n            }\n            this.$video.srcObject = null;\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return true;\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if (!this._paused) return false;\n        stopStream();\n        return true;\n    }\n\n    async setCamera(facingModeOrDeviceId) {\n        if (facingModeOrDeviceId === this._preferredCamera) return;\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        await this._restartVideoStream();\n    }\n\n    static async scanImage(\n        imageOrFileOrUrl,\n        scanRegion = null,\n        qrEngine = null,\n        canvas = null,\n        disallowCanvasResizing = false,\n        alsoTryWithoutScanRegion = false\n    ) {\n        const gotExternalEngine = !!qrEngine;\n\n        try {\n            let image;\n            let canvasContext;\n            [qrEngine, image] = await Promise.all([\n                qrEngine || QrScanner.createQrEngine(),\n                QrScanner._loadImage(imageOrFileOrUrl),\n            ]);\n            [canvas, canvasContext] = this._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n\n            if (qrEngine instanceof Worker) {\n                if (!gotExternalEngine) {\n                    // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n                    qrEngine.postMessage({ type: 'inversionMode', data: 'both' });\n                }\n                return await new Promise((resolve, reject) => {\n                    let timeout, onMessage, onError;\n                    onMessage = event => {\n                        if (event.data.type !== 'qrResult') {\n                            return;\n                        }\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve(event.data.data);\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (e) => {\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngine.addEventListener('message', onMessage);\n                    qrEngine.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n                    qrEngine.postMessage({\n                        type: 'decode',\n                        data: imageData\n                    }, [imageData.data.buffer]);\n                });\n            } else {\n                return await Promise.race([\n                    new Promise((resolve, reject) => window.setTimeout(() => reject('Scanner error: timeout'), 10000)),\n                    (async () => {\n                        try {\n                            const [scanResult] = await qrEngine.detect(canvas);\n                            if (!scanResult) throw QrScanner.NO_QR_CODE_FOUND;\n                            return scanResult.rawValue;\n                        } catch (e) {\n                            throw `Scanner error: ${e instanceof Error ? e.message : e}`;\n                        }\n                    })(),\n                ]);\n            }\n        } catch (e) {\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\n            return await QrScanner.scanImage(imageOrFileOrUrl, null, qrEngine, canvas, disallowCanvasResizing);\n        } finally {\n            if (!gotExternalEngine) {\n                QrScanner._postWorkerMessage(qrEngine, 'close');\n            }\n        }\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n        // well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n        // and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    static async createQrEngine(workerPath = QrScanner.WORKER_PATH) {\n        const hasNativeBarcodeDetector = 'BarcodeDetector' in window && BarcodeDetector.getSupportedFormats\n            ? (await BarcodeDetector.getSupportedFormats()).includes('qr_code')\n            : false;\n        return hasNativeBarcodeDetector ? new BarcodeDetector({ formats: ['qr_code'] }) : new Worker(workerPath);\n    }\n\n    _onPlay() {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._scanFrame();\n    }\n\n    _onLoadedMetaData() {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _calculateScanRegion(video) {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(async () => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n\n            let result;\n            try {\n                result = await QrScanner.scanImage(\n                    this.$video,\n                    this._scanRegion,\n                    this._qrEnginePromise,\n                    this.$canvas\n                );\n            } catch (error) {\n                if (!this._active) return;\n                const errorMessage = error.message || error;\n                if (errorMessage.includes('service unavailable')) {\n                    // When the native BarcodeDetector crashed, create a new one\n                    this._qrEnginePromise = QrScanner.createQrEngine();\n                }\n                this._onDecodeError(error);\n            }\n\n            if (result) {\n                this._onDecode(result);\n            }\n\n            this._scanFrame();\n        });\n    }\n\n    _onDecodeError(error) {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    async _getCameraStream() {\n        if (!navigator.mediaDevices) throw 'Camera not found.';\n\n        const preferenceType = this._preferredCamera === 'environment' || this._preferredCamera === 'user'\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                // mode, even for exact facingMode constraints.\n                const facingMode = this._getFacingMode(stream)\n                    || (constraints.facingMode\n                        ? this._preferredCamera // _preferredCamera is a facing mode and we are able to fulfill it\n                        : (this._preferredCamera === 'environment'\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\n                        )\n                    );\n                return { stream, facingMode };\n            } catch (e) {}\n        }\n\n        throw 'Camera not found.';\n    }\n\n    async _restartVideoStream() {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        const paused = await this.pause(true);\n        if (!paused || wasPaused || !this._active) return;\n        await this.start();\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    _getFacingMode(videoStream) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    static _drawToCanvas(image, scanRegion=null, canvas=null, disallowCanvasResizing=false) {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width? scanRegion.width : image.width || image.videoWidth;\n        const scanRegionHeight = scanRegion && scanRegion.height? scanRegion.height : image.height || image.videoHeight;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height\n        );\n        return [canvas, context];\n    }\n\n    static async _loadImage(imageOrFileOrBlobOrUrl) {\n        if (imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement || imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrBlobOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas) {\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof(imageOrFileOrBlobOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl;\n            }\n            try {\n                await QrScanner._awaitImageLoad(image);\n                return image;\n            } finally {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n            }\n        } else {\n            throw 'Unsupported image type.';\n        }\n    }\n\n    static async _awaitImageLoad(image) {\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\n        await new Promise((resolve, reject) => {\n            let onLoad, onError;\n            onLoad = () => {\n                image.removeEventListener('load', onLoad);\n                image.removeEventListener('error', onError);\n                resolve();\n            };\n            onError = () => {\n                image.removeEventListener('load', onLoad);\n                image.removeEventListener('error', onError);\n                reject('Image load error');\n            };\n            image.addEventListener('load', onLoad);\n            image.addEventListener('error', onError);\n        });\n    }\n\n    static async _postWorkerMessage(qrEngineOrQrEnginePromise, type, data) {\n        const qrEngine = await qrEngineOrQrEnginePromise;\n        if (!(qrEngine instanceof Worker)) return;\n        qrEngine.postMessage({ type, data });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found';\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';\n"],"names":["QrScanner","length","listCameras","e","requestLabels","navigator","mediaDevices","openedStream","getUserMedia","audio","video","filter","device","kind","map","i","id","deviceId","label","track","stop","removeTrack","onDecode","canvasSizeOrOnDecodeError","_onDecodeError","canvasSizeOrCalculateScanRegion","_calculateScanRegion","preferredCamera","$video","$canvas","document","createElement","_onDecode","_legacyCanvasSize","DEFAULT_CANVAS_SIZE","_preferredCamera","_flashOn","_paused","_active","console","warn","_scanRegion","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","disablePictureInPicture","playsInline","muted","shouldHideVideo","hidden","body","contains","appendChild","requestAnimationFrame","computedStyle","display","style","setProperty","visibility","opacity","width","height","addEventListener","_qrEnginePromise","createQrEngine","stream","srcObject","_getCameraStream","getVideoTracks","getSettings","turnFlashOff","turnFlashOn","hasFlash","applyConstraints","advanced","torch","_restartVideoStream","removeEventListener","_postWorkerMessage","window","location","protocol","play","facingMode","_setVideoMirror","catch","pause","stopStreamImmediately","tracks","getTracks","stopStream","Promise","resolve","setTimeout","facingModeOrDeviceId","imageOrFileOrUrl","scanRegion","qrEngine","canvas","disallowCanvasResizing","alsoTryWithoutScanRegion","image","canvasContext","all","_loadImage","_drawToCanvas","Worker","gotExternalEngine","postMessage","type","data","reject","timeout","onMessage","onError","event","clearTimeout","NO_QR_CODE_FOUND","imageData","buffer","race","scanResult","rawValue","Error","message","scanImage","red","green","blue","useIntegerApproximation","inversionMode","workerPath","WORKER_PATH","includes","BarcodeDetector","getSupportedFormats","formats","_scanFrame","start","videoHeight","x","Math","round","videoWidth","scanRegionSize","y","downScaledWidth","downScaledHeight","paused","ended","readyState","result","error","log","min","constraint","preferenceType","exact","constraints","wasPaused","transform","videoStream","test","videoTrack","scanRegionWidth","scanRegionHeight","canvasWidth","canvasHeight","alpha","context","imageSmoothingEnabled","drawImage","scanRegionX","scanRegionY","imageOrFileOrBlobOrUrl","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","Blob","URL","src","createObjectURL","revokeObjectURL","complete","naturalWidth","onLoad","qrEngineOrQrEnginePromise"],"mappings":"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"}