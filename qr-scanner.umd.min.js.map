{"version":3,"file":"qr-scanner.umd.min.js","sources":["src/qr-scanner.ts"],"sourcesContent":["export default class QrScanner {\n    static readonly DEFAULT_CANVAS_SIZE = 400;\n    static readonly NO_QR_CODE_FOUND = 'No QR code found';\n    static WORKER_PATH = 'qr-scanner-worker.min.js';\n\n    static async hasCamera(): Promise<boolean> {\n        try {\n            return !!(await QrScanner.listCameras(false)).length;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    static async listCameras(requestLabels = false): Promise<Array<QrScanner.Camera>> {\n        if (!navigator.mediaDevices) return [];\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, ask for camera permission by opening a stream, if\n        // labels were requested.\n        let openedStream: MediaStream | undefined;\n        if (requestLabels) {\n            try {\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n            } catch (e) {\n                // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in\n                // use and some browsers disallow a second stream.\n            }\n        }\n        try {\n            const devices = await navigator.mediaDevices.enumerateDevices();\n            return devices.filter(device => device.kind === 'videoinput').map((device, i) => ({\n                id: device.deviceId,\n                label: device.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            }));\n        } finally {\n            // close the stream we just opened for getting camera access for listing the device labels\n            if (openedStream) {\n                for (const track of openedStream.getTracks()) {\n                    track.stop();\n                    openedStream.removeTrack(track);\n                }\n            }\n        }\n    }\n\n    $video: HTMLVideoElement;\n    $canvas: HTMLCanvasElement;\n    private readonly _onDecode: (result: string) => void;\n    private _preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId;\n    private _scanRegion: QrScanner.ScanRegion;\n    private _legacyCanvasSize: number = QrScanner.DEFAULT_CANVAS_SIZE;\n    private _qrEnginePromise: Promise<Worker | BarcodeDetector>\n    private _active: boolean = false;\n    private _paused: boolean = false;\n    private _flashOn: boolean = false;\n\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        canvasSize?: number,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(video: HTMLVideoElement, onDecode: (result: string) => void, canvasSize?: number);\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        canvasSizeOrOnDecodeError?: number | ((error: Error | string) => void),\n        canvasSizeOrCalculateScanRegion?: number | ((video: HTMLVideoElement) => QrScanner.ScanRegion),\n        preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId = 'environment',\n    ) {\n        canvasSizeOrOnDecodeError = canvasSizeOrOnDecodeError || this._onDecodeError;\n        canvasSizeOrCalculateScanRegion = canvasSizeOrCalculateScanRegion || this._calculateScanRegion;\n\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._preferredCamera = preferredCamera;\n\n        if (typeof canvasSizeOrOnDecodeError === 'number') {\n            // legacy function signature where the third argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrOnDecodeError;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._onDecodeError = canvasSizeOrOnDecodeError;\n        }\n\n        if (typeof canvasSizeOrCalculateScanRegion === 'number') {\n            // legacy function signature where the fourth argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrCalculateScanRegion;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._calculateScanRegion = canvasSizeOrCalculateScanRegion;\n        }\n\n        this._scanRegion = this._calculateScanRegion(video);\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        // @ts-ignore\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        // @ts-ignore\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const computedStyle = window.getComputedStyle(video);\n            if (computedStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (computedStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = '0';\n                video.style.width = '0';\n                video.style.height = '0';\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    async hasFlash(): Promise<boolean> {\n        let stream: MediaStream | undefined;\n        try {\n            if (this.$video.srcObject) {\n                if (!(this.$video.srcObject instanceof MediaStream)) return false; // srcObject is not a camera stream\n                stream = this.$video.srcObject;\n            } else {\n                stream = (await this._getCameraStream()).stream;\n            }\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\n        } catch (e) {\n            return false;\n        } finally {\n            // close the stream we just opened for detecting whether it supports flash\n            if (stream && stream !== this.$video.srcObject) {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                for (const track of stream.getTracks()) {\n                    track.stop();\n                    stream.removeTrack(track);\n                }\n            }\n        }\n    }\n\n    isFlashOn(): boolean {\n        return this._flashOn;\n    }\n\n    async toggleFlash(): Promise<void> {\n        if (this._flashOn) {\n            await this.turnFlashOff();\n        } else {\n            await this.turnFlashOn();\n        }\n    }\n\n    async turnFlashOn(): Promise<void> {\n        if (this._flashOn) return;\n        this._flashOn = true;\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\n        try {\n            if (!await this.hasFlash()) throw 'No flash available';\n            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash\n            await (this.$video.srcObject as MediaStream).getVideoTracks()[0].applyConstraints({\n                // @ts-ignore: constraint 'torch' is unknown to ts\n                advanced: [{ torch: true }],\n            });\n        } catch (e) {\n            this._flashOn = false;\n            throw e;\n        }\n    }\n\n    async turnFlashOff(): Promise<void> {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        await this._restartVideoStream();\n    }\n\n    destroy(): void {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    async start(): Promise<void> {\n        if (this._active && !this._paused) return;\n\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n\n        this._active = true;\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return;\n        }\n\n        try {\n            const { stream, facingMode } = await this._getCameraStream();\n            this.$video.srcObject = stream;\n            this.$video.play();\n            this._setVideoMirror(facingMode);\n\n            // Restart the flash if it was previously on\n            if (this._flashOn) {\n                this._flashOn = false; // force turnFlashOn to restart the flash\n                this.turnFlashOn().catch(() => {});\n            }\n        } catch (e) {\n            this._active = false;\n            throw e;\n        }\n    }\n\n    stop(): void {\n        this.pause();\n        this._active = false;\n    }\n\n    async pause(stopStreamImmediately = false): Promise<boolean> {\n        this._paused = true;\n        if (!this._active) return true;\n        this.$video.pause();\n\n        const stopStream = () => {\n            if (this.$video.srcObject instanceof MediaStream) {\n                // revoke srcObject only if it's a stream which was likely set by us\n                for (const track of this.$video.srcObject.getTracks()) {\n                    track.stop(); //  note that this will also automatically turn the flashlight off\n                    this.$video.srcObject.removeTrack(track);\n                }\n                this.$video.srcObject = null;\n            }\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return true;\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if (!this._paused) return false;\n        stopStream();\n        return true;\n    }\n\n    async setCamera(facingModeOrDeviceId: QrScanner.FacingMode | QrScanner.DeviceId): Promise<void> {\n        if (facingModeOrDeviceId === this._preferredCamera) return;\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        await this._restartVideoStream();\n    }\n\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegion?: QrScanner.ScanRegion | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing: boolean = false,\n        alsoTryWithoutScanRegion: boolean = false,\n    ): Promise<string> {\n        const gotExternalEngine = !!qrEngine;\n\n        try {\n            let image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n                | SVGImageElement;\n            let canvasContext: CanvasRenderingContext2D;\n            [qrEngine, image] = await Promise.all([\n                qrEngine || QrScanner.createQrEngine(),\n                QrScanner._loadImage(imageOrFileOrBlobOrUrl),\n            ]);\n            [canvas, canvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n\n            if (qrEngine instanceof Worker) {\n                const qrEngineWorker = qrEngine; // for ts to know that it's still a worker later in the event listeners\n                if (!gotExternalEngine) {\n                    // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n                    qrEngineWorker.postMessage({ type: 'inversionMode', data: 'both' });\n                }\n                return await new Promise((resolve, reject) => {\n                    let timeout: number;\n                    let onMessage: (event: MessageEvent) => void;\n                    let onError: (error: ErrorEvent | string) => void;\n                    onMessage = (event: MessageEvent) => {\n                        if (event.data.type !== 'qrResult') {\n                            return;\n                        }\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve(event.data.data);\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (error: ErrorEvent | string) => {\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !error ? 'Unknown Error' : ((error as ErrorEvent).message || error);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngineWorker.addEventListener('message', onMessage);\n                    qrEngineWorker.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\n                    qrEngineWorker.postMessage({\n                        type: 'decode',\n                        data: imageData\n                    }, [imageData.data.buffer]);\n                });\n            } else {\n                return await Promise.race([\n                    new Promise<string>((resolve, reject) => window.setTimeout(\n                        () => reject('Scanner error: timeout'),\n                        10000,\n                    )),\n                    (async (): Promise<string> => {\n                        try {\n                            const [scanResult] = await qrEngine.detect(canvas!);\n                            if (!scanResult) throw QrScanner.NO_QR_CODE_FOUND;\n                            return scanResult.rawValue;\n                        } catch (e) {\n                            throw `Scanner error: ${(e as Error).message || e}`;\n                        }\n                    })(),\n                ]);\n            }\n        } catch (e) {\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\n            return await QrScanner.scanImage(imageOrFileOrBlobOrUrl, null, qrEngine, canvas, disallowCanvasResizing);\n        } finally {\n            if (!gotExternalEngine) {\n                QrScanner._postWorkerMessage(qrEngine!, 'close');\n            }\n        }\n    }\n\n    setGrayscaleWeights(red: number, green: number, blue: number, useIntegerApproximation: boolean = true): void {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n        // well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode: QrScanner.InversionMode): void {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n        // and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    static async createQrEngine(workerPath: string = QrScanner.WORKER_PATH): Promise<Worker | BarcodeDetector> {\n        const hasNativeBarcodeDetector = 'BarcodeDetector' in window && BarcodeDetector.getSupportedFormats\n            ? (await BarcodeDetector.getSupportedFormats()).includes('qr_code')\n            : false;\n        return hasNativeBarcodeDetector ? new BarcodeDetector({ formats: ['qr_code'] }) : new Worker(workerPath);\n    }\n\n    private _onPlay(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._scanFrame();\n    }\n\n    private _onLoadedMetaData(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n    }\n\n    private _onVisibilityChange(): void {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    private _calculateScanRegion(video: HTMLVideoElement): QrScanner.ScanRegion {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    private _scanFrame(): void {\n        if (!this._active || this.$video.paused || this.$video.ended) return;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(async () => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n\n            let result: string | undefined;\n            try {\n                result = await QrScanner.scanImage(\n                    this.$video,\n                    this._scanRegion,\n                    this._qrEnginePromise,\n                    this.$canvas,\n                );\n            } catch (error) {\n                if (!this._active) return;\n                const errorMessage = (error as Error).message || error as string;\n                if (errorMessage.includes('service unavailable')) {\n                    // When the native BarcodeDetector crashed, create a new one\n                    this._qrEnginePromise = QrScanner.createQrEngine();\n                }\n                this._onDecodeError(error as Error | string);\n            }\n\n            if (result) {\n                this._onDecode(result);\n            }\n\n            this._scanFrame();\n        });\n    }\n\n    private _onDecodeError(error: Error | string): void {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    private async _getCameraStream(): Promise<{ stream: MediaStream, facingMode: QrScanner.FacingMode }> {\n        if (!navigator.mediaDevices) throw 'Camera not found.';\n\n        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera: Array<MediaTrackConstraints> = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                // mode, even for exact facingMode constraints.\n                const facingMode = this._getFacingMode(stream)\n                    || (constraints.facingMode\n                        ? this._preferredCamera as QrScanner.FacingMode // a facing mode we were able to fulfill\n                        : (this._preferredCamera === 'environment'\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\n                        )\n                    );\n                return { stream, facingMode };\n            } catch (e) {}\n        }\n\n        throw 'Camera not found.';\n    }\n\n    private async _restartVideoStream(): Promise<void> {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        const paused = await this.pause(true);\n        if (!paused || wasPaused || !this._active) return;\n        await this.start();\n    }\n\n    private _setVideoMirror(facingMode: QrScanner.FacingMode): void {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode === 'user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    private _getFacingMode(videoStream: MediaStream): QrScanner.FacingMode | null {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    private static _drawToCanvas(\n        image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement,\n        scanRegion?: QrScanner.ScanRegion | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing= false,\n    ): [HTMLCanvasElement, CanvasRenderingContext2D] {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width\n            ? scanRegion.width\n            : (image as HTMLVideoElement).videoWidth || image.width as number;\n        const scanRegionHeight = scanRegion && scanRegion.height\n            ? scanRegion.height\n            : (image as HTMLVideoElement).videoHeight || image.height as number;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false })!;\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height,\n        );\n        return [canvas, context];\n    }\n\n    private static async _loadImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n    ): Promise<HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n        | SVGImageElement > {\n        if (imageOrFileOrBlobOrUrl instanceof Image) {\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement\n            || imageOrFileOrBlobOrUrl instanceof SVGImageElement\n            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas\n            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl.toString();\n            }\n            try {\n                await QrScanner._awaitImageLoad(image);\n                return image;\n            } finally {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n            }\n        } else {\n            throw 'Unsupported image type.';\n        }\n    }\n\n    private static async _awaitImageLoad(image: HTMLImageElement): Promise<void> {\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\n        await new Promise<void>((resolve, reject) => {\n            const listener = (event: ErrorEvent | Event) => {\n                image.removeEventListener('load', listener);\n                image.removeEventListener('error', listener);\n                if (event instanceof ErrorEvent) {\n                    reject('Image load error');\n                } else {\n                    resolve();\n                }\n            };\n            image.addEventListener('load', listener);\n            image.addEventListener('error', listener);\n        });\n    }\n\n    private static async _postWorkerMessage(\n        qrEngineOrQrEnginePromise: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector>,\n        type: string,\n        data?: any,\n    ): Promise<void> {\n        const qrEngine = await qrEngineOrQrEnginePromise;\n        if (!(qrEngine instanceof Worker)) return;\n        qrEngine.postMessage({ type, data });\n    }\n}\n\ndeclare namespace QrScanner {\n    export interface ScanRegion {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        downScaledWidth?: number;\n        downScaledHeight?: number;\n    }\n\n    export type FacingMode = 'environment' | 'user';\n    export type DeviceId = string;\n\n    export interface Camera {\n        id: DeviceId;\n        label: string;\n    }\n\n    export type InversionMode = 'original' | 'invert' | 'both';\n}\n\n// simplified from https://wicg.github.io/shape-detection-api/#barcode-detection-api\ndeclare class BarcodeDetector {\n    constructor(options?: { formats: string[] });\n    static getSupportedFormats(): Promise<string[]>;\n    detect(image: ImageBitmapSource): Promise<Array<{ rawValue: string }>>;\n}\n\n"],"names":["QrScanner","constructor","video","onDecode","canvasSizeOrOnDecodeError","canvasSizeOrCalculateScanRegion","preferredCamera","DEFAULT_CANVAS_SIZE","_onDecodeError","_calculateScanRegion","$video","$canvas","document","createElement","_onDecode","_preferredCamera","_legacyCanvasSize","console","warn","_scanRegion","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","disablePictureInPicture","playsInline","muted","shouldHideVideo","hidden","body","contains","appendChild","requestAnimationFrame","computedStyle","display","style","setProperty","visibility","opacity","width","height","addEventListener","_qrEnginePromise","createQrEngine","hasCamera","length","listCameras","e","requestLabels","navigator","mediaDevices","openedStream","getUserMedia","audio","filter","device","kind","map","i","id","deviceId","label","track","stop","removeTrack","hasFlash","stream","srcObject","MediaStream","_getCameraStream","getVideoTracks","getSettings","isFlashOn","_flashOn","toggleFlash","turnFlashOff","turnFlashOn","_active","_paused","applyConstraints","advanced","torch","_restartVideoStream","destroy","removeEventListener","_postWorkerMessage","start","window","location","protocol","play","facingMode","_setVideoMirror","catch","pause","stopStreamImmediately","getTracks","stopStream","Promise","resolve","setTimeout","setCamera","facingModeOrDeviceId","scanImage","imageOrFileOrBlobOrUrl","scanRegion","qrEngine","canvas","disallowCanvasResizing","alsoTryWithoutScanRegion","image","canvasContext","all","_loadImage","_drawToCanvas","Worker","gotExternalEngine","qrEngineWorker","postMessage","type","data","reject","timeout","onMessage","onError","event","clearTimeout","NO_QR_CODE_FOUND","error","imageData","buffer","race","scanResult","rawValue","message","setGrayscaleWeights","red","green","blue","useIntegerApproximation","setInversionMode","inversionMode","workerPath","WORKER_PATH","includes","BarcodeDetector","getSupportedFormats","formats","_scanFrame","x","Math","round","videoWidth","scanRegionSize","y","videoHeight","downScaledWidth","downScaledHeight","paused","ended","readyState","result","log","min","constraint","preferenceType","exact","constraints","wasPaused","transform","_getFacingMode","videoStream","test","videoTrack","scanRegionWidth","scanRegionHeight","canvasWidth","canvasHeight","alpha","context","imageSmoothingEnabled","drawImage","scanRegionX","scanRegionY","Image","_awaitImageLoad","HTMLVideoElement","HTMLCanvasElement","SVGImageElement","OffscreenCanvas","ImageBitmap","File","Blob","URL","src","createObjectURL","toString","revokeObjectURL","complete","naturalWidth","listener","ErrorEvent","qrEngineOrQrEnginePromise"],"mappings":"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"}